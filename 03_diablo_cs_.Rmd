---
title: "Big Small Draft"
author: "Casey P. Shannon"
date: '`r sprintf("Last rendered on: %s", format(Sys.time(), "%d %B, %Y, %H:%M %Z"))`'
output:
  tint::tintHtml:
  self_contained: yes
subtitle: An Integrative Analysis of the EPIC-HIPC Gambia Pilot Omic Datasets
link-citations: yes
---
  
  Questions:
  
  - Look at NOS vs. homoarginine (substrate of NOS, which activates inflammation) is dropping.

```{r imports}
library(tidyverse)
library(ggalt)
library(ggrepel)
library(ggthemes)
library(cowplot)
library(ggraph)
library(igraph)
# !diagnostics off
library(tint)

# helpers
root = '~/projects/asthma/example_diablo'
source(paste0(root, '/code/mixOmics_plotting_helpers.r'))
setwd(root)
```

```{r setup}
# invalidate cache when the package version changes
knitr::opts_chunk$set(tidy = FALSE, warning = FALSE, error = FALSE, message = FALSE, 
                      cache.extra = packageVersion('tint'), dev = 'svg', dpi = 300)
options(htmltools.dir.version = FALSE)

# cols <- c('#e41a1c', '#377eb8', '#4daf4a', '#984ea3')
cols <- RColorBrewer::brewer.pal('Set1', n = 5)
# re-order so that DOL 0 is purple...
# cols <- cols[c(4, 1:3, 5)]

# instatiate biomaRt
# mart can fail - retry until it doesn't...
mart <- NULL
repeat {
  mart <- tryCatch(biomaRt::useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl"), error = identity)
  if (!is(mart, "error"))
    break
}

```

```{r load_data, cache=TRUE}
# load datasets ----
meta <- readRDS(paste0(root, '/data/metadata.rds'))

# include cell counts
cells <- dplyr::select(meta, CD8:NK) %>% as.matrix()
rownames(cells) <- meta$sample.id

X <- list(
  # 'Imputed cells'      = cells,
  'Flow cytometry'     = readRDS(paste0(root, '/data/hipc_flow_concs.rds')),
  # 'Flow cytometry'     = readRDS(paste0(root, '/data/hipc_flow_concs.rds') %>% asinh(),
  # 'Flow cytometry'     = readRDS(paste0(root, '/data/hipc_flow_autoprops_concs.rds')),
  'Luminex cytokine'   = readRDS(paste0(root, '/data/hipc_cytokine_concs.rds')),
  'Metabolomics'       = readRDS(paste0(root, '/data/hipc_metabolomics_concs.rds')),
  # 'Metabolomics'       = readRDS(paste0(root, '/data/hipc_metabolomics_eigens.rds')),
  'Proteomics'         = readRDS(paste0(root, '/data/hipc_protein_ratios_updated.rds')),
  # 'Transcriptomics'    = readRDS(paste0(root, '/data/hipc_hancock_counts_sva_resequenced.rds'))
  'Transcriptomics'    = readRDS(paste0(root, '/data/hipc_hancock_counts_resequenced.rds'))
)

# # remove H09 - outlier - to test...
# X <- X %>% map(~ .[!grepl('H09', rownames(.)), ])
# meta <- meta %>% filter(!grepl('H09', subject.id))
```

```{r indexed_vs_nonindexed, cache=TRUE, eval=FALSE}
# save imported data for univariate things later on
Z <- X[c('Proteomics', 'Metabolomics', 'Transcriptomics')]

# first constrict metadata table from rownames
z_meta <- map(Z, ~ tibble(id = rownames(.))) %>% 
  map(separate, id, into = c('subject', 'grp', 'day')) %>% 
  map(mutate, day = gsub('day', 'DOL', day))

# only keep paired samples in each omics
Z <- map2(z_meta, Z, ~ {
  .x <- .x %>% group_by(subject) %>% mutate(keep = n() > 1) %>% ungroup()
  list(meta = .x[.x$keep, ], data = .y[.x$keep, ])
})

rm(z_meta)

# helper remove nearZeroVar
var_filter <- function(x) {
  y <- mixOmics::nearZeroVar(x)
  if(length(y$Position) > 0)
    x[ , -y$Position]
  else
    x
}

# carry out PCA
Z <- map(Z, ~ {
  # get rid of near zero vars
  .$data <- var_filter(.$data)
  .$pca = mixOmics::pca(.$data, ncomp = 2, scale = T, center = T)
  .$pca_multilevel = mixOmics::pca(.$data, ncomp = 2, scale = T, center = T, multilevel = .$meta$subject)
  .
}) %>% transpose()

pca_plots <- list()
pca_plots$simple <- map2(Z$pca, Z$meta, ggCompPlot)
pca_plots$multilevel <- map2(Z$pca_multilevel, Z$meta, ggCompPlot)
pca_plots <- modify_depth(pca_plots, 2, ~ . + scale_colour_manual(name = 'DOL', values = cols))
pca_plots <- pca_plots %>% 
  modify_depth(2, ~ {
    .$labels$x <- gsub('component ', 'PC', .$labels$x)
    .$labels$y <- gsub('component ', 'PC', .$labels$y)
    .
  })

pca_plots <- pca_plots %>% 
  modify_depth(2, ~ tibble(gg = list(.))) %>% 
  map(bind_rows, .id = 'block') %>% 
  bind_rows(.id = 'type')

pwalk(pca_plots, function(type, block, gg) {
  f <- sprintf('figures/figure 2/pca - %s - %s', type, tolower(block))
  save_plot(paste0(f, '.png'), gg, ncol = 1.1)
  save_plot(paste0(f, '.pdf'), gg, ncol = 1.1)
})
```

```{r cleanup_subset, cache=TRUE}

# only complete subjects
complete <- purrr::map(X, rownames) %>% purrr::reduce(intersect)
foo <- gsub('^(...).+', '\\1', complete)
complete <- complete[foo %in% foo[duplicated(foo)]]
meta <- meta %>% filter(sample.id %in% complete)
X <- purrr::map(X, function(x) x[complete, ])

# reorder
X <- lapply(X, function(x) x[meta$sample.id, ])

# only keep top 50% most variable features
X <- lapply(X, function(x) {
  mads <- matrixStats::colMads(x, na.rm = T)
  x <- x[ , mads != 0]
  
  mads <- matrixStats::colMads(x, na.rm = T)
  # if (ncol(x) > 1000)
  x[ , mads > quantile(mads, 0.5, na.rm = T)]
  # else
  # x
})

# structure
str(X, 1)

# make pretty names ----
# transcriptomics
table <- biomaRt::getBM(
  attributes = c('ensembl_gene_id', 'hgnc_symbol'), 
  filters = 'ensembl_gene_id', 
  values = colnames(X$Transcriptomics), 
  mart = mart) %>% 
  group_by(ensembl_gene_id) %>% 
  summarise(gene = paste(hgnc_symbol, collapse = ', ')) %>% 
  mutate(label = paste0(gene, '\n', ensembl_gene_id))

# be careful about missing matches...
colnames(X$Transcriptomics) <- data.frame(cols = colnames(X$Transcriptomics), stringsAsFactors = F) %>% 
  left_join(table, by = c('cols' = 'ensembl_gene_id')) %>% 
  mutate(label = ifelse(is.na(label), cols, label)) %>% 
  last()

# clean up
rm(cells, complete, mart, table)

# paired treatment
A <- X %>% map(mixOmics::withinVariation, design = as.data.frame(select(meta, subject.id)))
str(A, 1)

# make inputs for diablo
Y <- meta$day

# all same order?
purrr::map(A, ~ all(names(Y) == rownames(.x)))
```

# Analysis

## Comparing single to integrative omics
`r newthought('First, we visualize the projections')` obtained from a **single-omics** analysis using biplots. Data were first adjusted for within subject variation using `mixOmics::withinVariation` and models subsequently built in an **unsupervised** manner using principal component analysis (PCA).

```{r, fig.cap=sprintf('**PCA %s**', names(A)), fig.width=6.5, fig.height=4.5, cache=TRUE, results='hide'}
# PCA
A %>%
  map(mixOmics::pca,
      ncomp = nrow(.),
      center = T,
      scale = T) %>%
  map(ggCompPlot, meta) %>%
  map(~ . + theme(legend.position = 'bottom', aspect.ratio = 1)) %>% 
  plot_grid(plotlist = ., labels = names(.), nrow = 1, label_x = 0.2)
```

It is clear that the development of the immune system over the first week of life is a major source of variation in most of the data blocks, though some days are more difficult to separate than results/enrichrs.

## Cross-validation
`r newthought('Next, we will fit a supervised, constrained multi-omics')` model (fully constrained DIABLO) to study the question of immune ontogeny in the first week of life across the various data blocks. This model has a number of hyperparameters that need to be specified, such as number of components, and number of features/component.

Determining the "correct" values for these hyperparameters is a difficult task. A common strategy is to use the hyperparamters that minimize out-of-sample error rate, i.e. those that result in models that best generalize to new data. This can be estimated by using cross-validation.

We carried out 10-fold cross-validation in order to compare the generalizability of various models. The results are shown below.
```{r kfold, cache=TRUE}
# cross-validation
set.seed(165)
# set.seed(199)

# hyperparameters
nblocks <- length(A)
keeps <- c(1, 2, 3, 4, 5, 10, 15)
names(keeps) <- keeps

# models
# design_null <- matrix(0, nrow = nblocks, ncol = nblocks)
design_full <- matrix(1, nrow = nblocks, ncol = nblocks)
diag(design_full) <- 0

models <- list(
  # null = list(d = design_null, X = A),
  full = list(d = design_full, X = A)
)

iter <- 1:20
names(iter) <- iter
cv <- lapply(iter, function(i) {
  lapply(keeps, function(k) {
    # helper
    cv_results <- function(x) {
      res <- mixOmics::splsda(X = x, Y = Y, ncomp = ncomp, keepX = k)
      cv  <- mixOmics::perf(res, validation = 'Mfold', folds = 5, progressBar = F)
      # cv  <- mixOmics::perf(res, validation = 'loo', progressBar = F)
      data.frame(comp = 1:ncomp, error = cv$error.rate$overall[ , 'mahalanobis.dist'])
    }
    
    # first, build splsda models in each block
    ncomp <- 5
    results <- models[[1]]$X %>% 
      map(cv_results) %>% 
      bind_rows(.id = 'block') %>% 
      tbl_df()
    results$model <- 'Single-omics'
    
    # next, build diablo model for each design matrix
    lapply(models, function(m) {
      keepX <- lapply(m$X, function(x) rep(k, ncomp))
      res <- mixOmics::block.splsda(X = m$X, Y = Y, ncomp = ncomp, keepX = keepX, 
                                    design = m$d, mode = "regression", 
                                    near.zero.var = T)
      cv  <- mixOmics::perf(res, validation = 'Mfold', folds = 5)
      # cv  <- mixOmics::perf(res, validation = 'loo')
      results <- data.frame(comp = 1:ncomp, block = 'Ensemble: Majority', 
                            error = cv$WeightedVote.error.rate$mahalanobis.dist['Overall.ER', ])
    }) %>% bind_rows(.id = 'model') %>% rbind(., results)
  }) %>% bind_rows(.id = 'nkeep')
}) %>% bind_rows(.id = 'iter')

cv <- cv %>% 
  tbl_df() %>% 
  arrange(error) %>% 
  mutate(nkeep = as.integer(nkeep),
         enrich = nkeep * comp)

cv$block <- factor(cv$block, 
                   levels = c(names(X), 'Ensemble: Majority'), 
                   labels = c(names(X), 'DIABLO - Constrained; Weighted Majority'))
cv$model <- factor(cv$model, levels = c('Single-omics', 'full'), 
                   labels = c('Single-omics', 'DIABLO - Constrained'))
```

```{r kfold_plot, fig.cap='**Cross-validation results**', fig.width=8, fig.height=3.5, echo=FALSE, results='hide', cache=TRUE}
cv %>% 
  filter(nkeep %in% c(1, 5, 10, 15)) %>%
  mutate(
    nkeep = factor(nkeep),
    block = factor(
      block, 
      labels = c('sPLS-DA\ncell', 'sPLS-DA\ncytokine', 'sPLS-DA\nmetabolite', 'sPLS-DA\nprotein', 'sPLS-DA\ntranscript', 'DIABLO\nintegration')
    )
  ) %>% 
  ggplot(aes(comp, error)) +
  stat_summary(fun.data = 'mean_cl_boot', geom = 'smooth', alpha = 1/3,
               aes(colour = factor(nkeep), group = paste(nkeep, model)),
               position = position_dodge(width = 1)) +
  # geom_line(aes(colour = factor(nkeep), group = paste(nkeep, model)), 
  #           position = position_dodge(width = 0.5)) +
  geom_hline(yintercept = c(0.50, 0.25, 0.10, 0.05), linetype = 'dotted') +
  facet_wrap(~block, nrow = 1) +
  # scale_color_canva('Features/component', palette = 'Warm and cool') +
  # scale_color_few(name = 'features/component') +
  scale_color_manual(name = 'features/component', values = cols) +
  scale_x_continuous(breaks = 1:5) +
  scale_y_continuous(breaks = c(0.05, 0.10, 0.25, 0.50), label = scales::percent) +
  theme(strip.background = element_blank(), 
        strip.text = element_text(size = 8), 
        legend.position = 'bottom') +
  labs(x = 'Model complexity\n(number of components)', y = 'Model error\n(lower is better)')

save_plot(
  'figures/Supplemental Figure 6 (cross-validation).png', 
  plot = last_plot(), 
  nrow = 1, 
  ncol = 2.5, 
  dpi = 600
)

svglite::svglite(
  'figures/Supplemental Figure 6 (cross-validation).svg', 
  width = 11, 
  height = 4, 
  # pointsize = 90,
  system_fonts = 'Roboto'
)
last_plot()
dev.off()

whichcv <- cv %>%
  tbl_df() %>% 
  group_by(block, model, nkeep, comp) %>% 
  summarise_all(mean) %>% 
  ungroup() %>% 
  mutate(error = round(error, 2)) %>% 
  arrange(error, comp) %>% 
  filter(model == 'DIABLO - Constrained') %>%
  slice(1) %>% 
  select(comp, nkeep, error)

cv %>%
  tbl_df() %>% 
  group_by(block, model, nkeep, comp) %>% 
  summarise(mean = mean(error), sd = sd(error)) %>% 
  group_by(block) %>% 
  arrange(mean, comp) %>% 
  slice(1) %>% 
  ungroup() %>% 
  arrange(mean) %>% 
  readr::write_csv('tables/summarized_kfold_cv.csv')

# test?
cv %>% group_by(block, comp, nkeep) %>% 
  summarise(mean = mean(error)) %>% 
  group_by(block) %>% 
  arrange(mean) %>% 
  slice(1) %>% 
  left_join(cv, by = c('block', 'comp', 'nkeep')) %>% 
  ungroup() -> cvv

# ttest: Transcriptomics > DIABLO error rate
cvv %>% 
  filter(grepl('DIABLO|Transcriptomics', block)) %>% 
  # t.test(error ~ block, data = ., alternative = 'two.sided')
  wilcox.test(error ~ block, data = ., alternative = 'two.sided', exact = F)

# cvv %>% 
#   filter(grepl('DIABLO|Transcriptomics', block)) %>% 
#   ggplot(aes(block, error)) +
#   geom_dotplot(binaxis = 'y', stackdir = 'center') +
#   stat_summary(fun.data = 'mean_cl_boot', geom = 'pointrange', colour = 'red')

# all comparisons by ANOVA
# hsd <- aov(error ~ block, data = cvv) %>% TukeyHSD()
# par(las = 1, mar = c(2, 30, 2, 2))
# plot(hsd)
```

A DIABLO model with `r whichcv$comp` components and `r whichcv$nkeep` features/component (total of `r whichcv$comp * whichcv$nkeep` features) resulted in the best out-of-sample performance (averaging a `r round(whichcv$error * 100, 2)`% out-of-sample error rate).

```{marginfigure}
**Interpreting biplots**  
  _Points_ that are close together correspond to observations that have similar scores on the components displayed in the plot. To the extent that these components fit the data well, the points also correspond to observations that have similar values on the variables.  

_Vectors_ point away from the origin in some direction. A vector points in the direction which is most like the variable represented by the vector. This is the direction which has the highest squared multiple correlation with the components. The length of the vector is proportional to the squared multiple correlation between the fitted values for the variable and the variable itself.  

The _angle_ between feature loading vectors corresponds to the relationship between features (correlation). Features with loading vectors pointing in the same direction are strongly positively correlated, while features with perpendicular loading vectors are not correlated.
```

## Model projections
`r newthought('Finally, we visualize the projections')` of the **__constrained__ multi-omics** model. Again, data were first adjusted for within subject variation using `mixOmics::withinVariation`. Models were then built in a **supervised** manner, jointly (fully constrained DIABLO). The model variates and loadings are visualized using biplots.

```{r comp_plot, fig.cap=sprintf('**DIABLO %s**', names(A)), fig.width=6.5, fig.height=4.5, cache=TRUE, results='hide'}
# hyperparameters
# optimal number of components and 
# features kept per component as
# determined by cross-validation
# ncomp <- whichcv$comp
# nkeep <- whichcv$nkeep

ncomp <- 2
nkeep <- 10

# build a constrained diablo model 
# using all data blocks as input
design_full <- matrix(1, nrow = length(A), ncol = length(A))
diag(design_full) <- 0
M <- A %>% 
  mixOmics::block.splsda(
    meta$day, 
    design = design_full, 
    ncomp = ncomp, 
    keepX = map(A, ~ rep(nkeep, ncomp))
  )

# saveRDS(M, 'diablo_model.rds')

M %>% ggCompPlot(meta, topn = 10, combined = T)
```

### Are Components Confounded by Sex
```{r, cache=TRUE, eval=FALSE}
# sex
M$variates %>% 
  head(-1) %>% 
  map(data.frame) %>% 
  map(as.list) %>% 
  at_depth(2, ~ lm(. ~ meta$sex)) %>% 
  at_depth(2, broom::tidy)
```

### Are Components Confounded by Vaccination Status
```{r, cache=TRUE, eval=FALSE}
# vaccination
M$variates %>% 
  head(-1) %>% 
  map(data.frame) %>% 
  map(as.list) %>% 
  at_depth(2, ~ lm(. ~ meta$grp)) %>% 
  at_depth(2, broom::tidy)
```

```{r extract_features}
# get model features
model_features <- map(1:ncomp, ~ {
  mixOmics::selectVar(M, comp = .) %>% 
    map(1) %>% 
    head(-1) %>% 
    map(as.data.frame, stringsAsFactors = F) %>% 
    bind_rows(.id = 'block')
}) %>% bind_rows(.id = 'component')
colnames(model_features)[3] <- 'feature'

# readr::write_csv(model_features, 'diablo_feature.csv')
```

```{r pairs_plots}
pairs <- M$variates %>%
  head(-1) %>% 
  map(~ .[ , 1]) %>% 
  do.call(cbind, .) %>% 
  as.data.frame() %>%
  rownames_to_column('id') %>% 
  separate(id, c('subject', 'grp', 'day'), sep = '_')
colnames(pairs) <- make.names(colnames(pairs))

pp <- GGally::ggpairs(pairs, aes(colour = day, fill = day), 
                      lower = list(continuous = ggally_ellipse), 
                      columns = make.names(head(M$names$blocks, -1))) +
  theme(panel.grid = element_blank(), strip.background = element_blank())

# fix colour palette
for (row in seq_len(pp$nrow))
  for (col in seq_len(pp$ncol)) {
    pp[row, col] <- pp[row, col] + 
      # scale_fill_canva(palette = 'Warm and cool') + 
      # scale_color_canva(palette = 'Warm and cool')
      scale_fill_few() + 
      scale_color_few()
  }

pp
save_plot('figures/component1_pairs_plot.png', pp, nrow = 2, ncol = 2, dpi = 600)
```

```{r consensus_plot}
consensus_plot <- M$variates %>% 
  head(-1) %>% # remove response block
  Reduce('+', .) %>%
  '/'(5) %>%
  cbind(meta, .) %>% 
  ggplot(aes(`comp 1`, `comp 2`, colour = day)) +
  geom_point(size = 3) +
  # geom_rug(alpha = 0.5) +
  stat_ellipse(aes(colour = day), level = 0.95, linetype = 'dashed', show.legend = F) +
  # scale_color_canva('Time', palette = 'Warm and cool') +
  # scale_color_few(name = '', labels = paste('DOL', c(0, 1, 3, 7))) +
  scale_color_manual(name = '', values = cols[1:4], labels = paste('DOL', c(0, 1, 3, 7))) +
  # theme(legend.position = 'none') +
  labs(x = 'DIABLO Comp. 1', y = 'DIABLO Comp. 2')

save_plot(
  filename = 'figures/figure_consensus_components.png', 
  consensus_plot, 
  dpi = 600, 
  base_aspect_ratio = 1.2
)

# separate variates for panel A
M$variates %>% 
  head(-1) %>% 
  map(~ {
    data.frame(.) %>% 
      rownames_to_column('id') %>% 
      separate(id, into = c('subject', 'grp', 'dol')) %>% 
      ggplot(aes(`comp.1`, `comp.2`, colour = dol)) +
      geom_point(size = 3) +
      scale_color_manual(values = cols) +
      theme(
        axis.title = element_blank(), 
        axis.text = element_blank(), 
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        legend.position = 'none'
      )
  }) %>% walk2(names(.), ., ~ save_plot(sprintf('figures/individual_variates_%s.png', make.names(tolower(.x))), plot = .y))

```

```{r single_omics_models}
# equivalent single-omics models to compare
library(glmnet)
I <- A %>%
  map(~ cv.glmnet(.,
                  y = meta$day,
                  family = 'multinomial',
                  alpha = 1,
                  nfolds = nrow(.),
                  type.measure = 'class'))
```

The first components across the data blocks are all highly correlated to each results/enrichr, and our response (days of life), by design. Each component can be thought of as a functional unit maximally correlated to the response. As such, comparing their membership can be insightful.

## Model correlation structure
`r newthought('Let us take a look at the correlation structure')` of the resulting model compared to that of models built separately on the various OMIC blocks.

```{r}
corr <- list()

corr$`Single-omics` <- map2(I, A, ~ {
  k <- glmnet:::predict.cv.glmnet(.x, type = 'nonzero', s = 'lambda.1se') %>%
    # k <- predict(.x, type = 'nonzero', s = 'lambda.1se') %>%
    unlist() %>%
    purrr::reduce(union)
  corMat <- .y[ , k]}) %>%
  purrr::reduce(cbind) %>%
  cor(method = 'pearson')

corr$DIABLO <- getCorMat(M, comp = 1:ncomp, method = 'pearson')
```

```{r corr_heatmaps}
corr_plot <- corr %>%
  purrr::map(~ {
    d <- hclust(dist(.))
    m <- .[d$order, d$order]
    g1 <- GGally::ggcorr(data = NULL, cor_matrix = m,
                         high = '#e64b35', low = '#3182bd', # per colour guide for hi-lo - Erin
                         hjust = 0, size = 0.1, colour = 'white', layout.exp = 0)
  })
```

```{r corr_dist}
# cut <- corr %>% unlist() %>% abs() %>% quantile(0.9)

cut <- corr %>% map(abs) %>% map(quantile, 0.75)
cutlines <- cut %>% bind_rows(.id = 'model') %>% select(-model) %>% gather(model, cut)

corr_dist_plot <- corr %>%
  purrr::map(reshape2::melt) %>%
  dplyr::bind_rows(.id = 'model') %>%
  dplyr::mutate(model = factor(model, levels = c('Single-omics', 'DIABLO'))) %>%
  ggplot(aes(abs(value), colour = model, fill = model)) +
  geom_density(alpha = 1/3) +
  # geom_vline(xintercept = 0) +
  geom_vline(data = cutlines, aes(xintercept = cut, colour = model), linetype = 'dashed') +
  # scale_colour_manual(values = c("#F21A00", "#3B9AB2")) +
  # scale_fill_manual(values = c("#F21A00", "#3B9AB2")) +
  scale_colour_manual(values = c("#e64b35", "#3182bd")) + # per colour guide for hi-lo - Erin
  scale_fill_manual(values = c("#e64b35", "#3182bd")) +   # per colour guide for hi-lo - Erin
  labs(x = 'correlation')
corr_dist_plot
save_plot('figures/compare_distribution_correlation.png', plot = corr_dist_plot, dpi = 600)
```

## Components form tightly intra-correlated communities
```{r make_graph}
library(igraph)
# edge density at cutoff
g <- purrr::map2(
  corr, 
  cut,
  ~ {
    g <- graph_from_adjacency_matrix(.x, weighted = T, mode = 'undirected', diag = F)
    g <- delete.edges(g, which(abs(E(g)$weight) <= .y))
    # g <- delete.edges(g, which(abs(E(g)$weight) <= quantile(abs(E(g)$weight), 0.75)))
    g <- delete.vertices(g, which(degree(g) == 0))
    g <- simplify(g)
    V(g)$label <- ""
    g
  })

# community detection
c <- purrr::map(g, ~ {
  g <- .
  E(g)$weight <- abs(E(g)$weight)
  cluster_edge_betweenness(g)
})

tibble(feature = c$DIABLO$names, module = c$DIABLO$membership) %>% 
  full_join(model_features) %>% 
  group_by(module, component) %>% 
  tally() %>% 
  spread(component, n)
```

```{r}
# compare models
table1 <- list(nvertices    = dplyr::bind_cols(purrr::map(g, ~ length(V(.)))),
               nedges       = dplyr::bind_cols(purrr::map(g, ~ length(E(.)))),
               #  ratio of the number of edges and the number of possible edges
               edge_density = dplyr::bind_cols(purrr::map(g, edge_density)),
               # probability that the adjacent vertices of a vertex are connected, i.e. clustering coefficient
               transitivity = dplyr::bind_cols(purrr::map(g, transitivity, type = 'global')),
               ncommunities = dplyr::bind_cols(purrr::map(c, length)),
               # ratio of the connectivity within communities to the connectivity across communities.
               modularity   = dplyr::bind_cols(purrr::map(c, modularity))) %>% 
  bind_rows(.id = 'metric')

table1 %>% knitr::kable()

readr::write_csv(table1, 'tables/table_network_properties.csv')

```

# Results Figure(s)
```{r}
enet_features <- map2(I, A, ~ {
  k <- glmnet:::predict.cv.glmnet(.x, type = 'nonzero', s = 'lambda.1se') %>%
    unlist() %>%
    purrr::reduce(union)
  colnames(.y)[k]
})

enet_features <- map2(names(enet_features), enet_features, ~ {
  foo <- rep(.x, length(.y))
  names(foo) <- .y
  foo
}) %>% unlist()

comps <- 1:ncomp
names(comps) <- comps
diablo_features <- map(comps, ~ {
  mixOmics::selectVar(M, comp = .) %>% 
    map(1) %>% 
    head(-1) %>% 
    map(as.data.frame, stringsAsFactors = F)
}) %>% 
  transpose() %>% 
  map(reduce, union) %>% 
  map(reduce, union)

diablo_features <- map2(names(diablo_features), diablo_features, ~ {
  foo <- rep(.x, length(.y))
  names(foo) <- .y
  foo
}) %>% unlist()

h <- list(single = enet_features, diablo = diablo_features)
labels <- tolower(c('Cell', 'Cytokine', 'Metabolite', 'Protein', 'Transcript'))

plots <- pmap(list(c = c, g = g, h = h) , function(c, g, h) {
  V(g)$community <- as.character(c$membership)
  V(g)$block <- h[c$names, drop = T]
  ggraph(g, layout = 'igraph', algorithm = 'mds') +
    geom_encircle(aes(x = x, y = y, group = factor(community)),
                  s_shape = 0.5, expand = 0.025) +
    geom_edge_fan(colour = 'lightgrey', show.legend = FALSE) +
    geom_node_point(aes(fill = factor(block)), shape = 21, colour = 'white', size = 4) +
    scale_x_continuous(expand = c(0.25, 0.25)) +
    scale_y_continuous(expand = c(0.25, 0.25)) +
    # ggthemes::scale_fill_few(name = '', palette = 'medium', labels = labels) +
    scale_fill_manual(name = '', values = cols, labels = labels) + # per colour guide - Erin
    # guides(colour = guide_legend(nrow = 2, byrow = TRUE)) +
    theme(aspect.ratio = 1.25, 
          # legend.position = 'bottom',
          axis.ticks = element_blank(),
          axis.text = element_blank(),
          axis.line = element_blank(),
          axis.title = element_blank())
})

# plotting
myplots <- M %>% ggCompPlot(meta, topn = 10, combined = T) %>% map(~ . + theme(aspect.ratio = 1))
myplots <- map2(labels, myplots, ~ .y + ggtitle(.x))
names(myplots) <- gsub(' ', '_', tolower(names(A)))

map2(names(myplots), myplots, ~ save_plot(sprintf('figures/figure_%s_integration.png', .x), .y, ncol = 1.5, nrow = 1.5, dpi = 600))

# clean up names in plots...
metabomap <- readr::read_csv('data/gambia/metabolomics/metabolomic_feature_mapping_file.csv')
myplots$metabolomics$layers[[7]]$data$names <- metabomap$`Sub Pathway`[match(myplots$metabolomics$layers[[7]]$data$names, metabomap$`Make.names()`)]

myplots$proteomics$layers[[7]]$data$names <- myplots$proteomics$layers[[7]]$data$names %>% 
  map(strsplit, '_') %>% 
  map(1) %>% 
  map(tail, 1) %>% 
  unlist()

myplots$transcriptomics$layers[[7]]$data$names <- myplots$transcriptomics$layers[[7]]$data$names %>% 
  map(strsplit, '\n') %>% 
  map(1) %>% 
  map(head, 1) %>% 
  unlist()

myplots$consensus <- consensus_plot + 
  labs(title = 'consensus', x = 'component 1\n', y = 'component 2\n') + 
  theme(aspect.ratio = 1)

myplots <- myplots[c(6, 1:5)]
grid <- plot_grid(plotlist = myplots, nrow = 2, labels = 'auto')
save_plot('figures/component_plot_grid.png', grid, ncol = 3, nrow = 2, dpi = 600)

# main figure
network_plot <- (function(plots) {
  # extract the legend from one of the plots
  legend <- get_legend(plots[[2]])
  # add the legend to the row we made earlier
  map2(plots, names(plots), ~ .x + ggtitle(.y) + theme(legend.position = 'none'))
})(plots)

# Fig1A
save_plot('figures/fig1_corr_heat1.svg', 
          corr_plot$`Single-omics` + 
            theme(legend.position = 'left', aspect.ratio = 1), 
          ncol = 1, nrow = 1, base_height = 3.5)

# Fig1B
save_plot('figures/fig1_corr_heat2.svg', 
          corr_plot$DIABLO + 
            theme(legend.position = 'left', aspect.ratio = 1), 
          ncol = 1, nrow = 1, base_height = 3.5)

# Fig1C
save_plot('figures/fig1_corrdist.svg', 
          corr_dist_plot + 
            theme(legend.position = 'bottom', aspect.ratio = 1), 
          ncol = 1, nrow = 1)

# Fig1D
save_plot('figures/fig1_network1.svg',   
          network_plot$`Single-omics` + 
            theme(plot.title = element_blank(), legend.position = 'right', plot.margin = unit(c(0, 0, 0, 0), 'cm')),
          ncol = 1, nrow = 1)

# Fig1E
save_plot('figures/fig1_network2.svg',   
          network_plot$DIABLO +
            theme(plot.title = element_blank(), legend.position = 'right', plot.margin = unit(c(0, 0, 0, 0), 'cm')),
          ncol = 1, nrow = 1)

# Fig1E
save_plot('figures/fig1_consensus.svg', 
          consensus_plot + 
            theme(legend.position = 'bottom', aspect.ratio = 1), 
          ncol = 1, nrow = 1)
```

# Enrichment Results
`r newthought('Finally, we look for gene set enrichment')` using the cytokines, proteins and transcripts identified by DIABLO.

```{r sear}
# find big communities
# modules <- split(c$DIABLO$names, c$DIABLO$membership)
# modules <- model_features %>% split(.$component)
# 
# modules <- modules[order(unlist(purrr::map(modules, length)), decreasing = T)]
# 
# modules <- modules %>% 
#   purrr::map(~ dplyr::tibble('feature' = .)) %>% 
#   dplyr::bind_rows(.id = 'module') %>% 
#   dplyr::left_join(model_features) %>% 
#   dplyr::select(block, component, module, feature)
# 
# e <- modules %>% 
#   split(.$component) %>% 
#   map(last)

e <- model_features %>% 
  split(.$component) %>% 
  map(pull, feature)

e$combined <- union(e$`1`, e$`2`)
e$enet <- names(enet_features)

names(e) <- c('DIABLOPC1', 'DIABLOPC2', 'Combined', 'Singleomics')
e <- map(e, ~ .[. != ''])

library(UpSetR)
svg('manuscript_figures/fig1_features_upset_plot.svg', width = 4, height = 4)
temp <- fromList(e[c(1, 2, 4)])
temp$name <- NA # upset can't highlight individual bars results/enrichrwise ?!?
upset(
  temp,
  nintersects = NA,
  mainbar.y.label = 'Feature intersection',
  sets = rev(c('DIABLOPC1', 'DIABLOPC2', 'Singleomics')), keep.order = T,
  text.scale = 1.5, point.size = 3, line.size = 1.5,
  queries = list(
    list(query = intersects,
         params = list("DIABLOPC1"), color = cols[[3]], active = T),
    list(query = intersects,
         params = list("DIABLOPC2"), color = cols[[3]], active = T),
    list(query = intersects,
         params = list("Singleomics"), color = cols[[2]], active = T))
)
dev.off()

# clean up names
mapping <- rbind(readr::read_csv('proteinNames_1.csv'),
                 readr::read_csv('luminexCytokineNames.csv'))

e <- e %>% 
  map(~ {
    x <- mapping$`Gene Symbols`[match(., mapping$`Data Names`)]
    ifelse(is.na(x), ., x)
  })

e <- e %>% 
  map(~ {
    x <- .
    x %>% gsub('^(.+)?\\n.+', '\\1', .) %>%
      # gsub('^.+_(.+)$', '\\1', .) %>%
      gsub('\\.', '', .)
  })

# enrichment
library(sear)
e2 <- map(e, sear)
# filtered
f <- e2 %>%
  map(~ {
    dplyr::select(., -members, -n_input, -n_geneset) %>%
      # dplyr::filter(collection %in% c('H', 'BTM') | (subcollection == 'CP:REACTOME')) %>%
      # dplyr::filter(collection == 'BTM') %>%
      dplyr::filter(subcollection == 'CP:REACTOME') %>%
      dplyr::arrange(fdr) %>%
      dplyr::filter(fdr < 0.25)
  })

# few <- ggthemes::few_pal()(5)

svg('manuscript_figures/fig1_genesets_upset_plot.svg', width = 4, height = 4)
temp <- fromList(map(f, pull, geneset)[c(1, 2, 4)])
temp$name <- NA # upset can't highlight individual bars results/enrichrwise ?!?
upset(
  temp, 
  nintersects = NA,
  mainbar.y.label = 'Geneset intersection',
  sets = rev(c('DIABLOPC1', 'DIABLOPC2', 'Singleomics')), keep.order = T,
  text.scale = 1.5, point.size = 3, line.size = 1.5,
  queries = list(
    list(query = intersects,
         params = list("DIABLOPC1"), color = cols[[3]], active = T),
    list(query = intersects,
         params = list("DIABLOPC2"), color = cols[[3]], active = T),
    list(query = intersects,
         params = list("Singleomics"), color = cols[[2]], active = T))
)
dev.off()

# map2(names(f), f, ~ readr::write_csv(.y, paste0('enrichment_results_component_', .x, '.csv')))
openxlsx::write.xlsx(f, 'manuscript_figures/Tables/DIABLO - reactome enrichment results by component.xlsx', 
                     asTable = T, firstRow = T, colWidths = T)
```

# Selected feature univariate rank
```{r}
library(limma)
day <- factor(meta$day, ordered = T)
# d <- model.matrix(~ meta$sex + meta$grp + day)
d <- model.matrix(~ meta$subject.id + day)
univar <- X %>%
  # univar <- A %>%
  map(~ {
    t(.) %>% 
      lmFit(d) %>% 
      eBayes() %>% 
      topTable(coef = 'day.L', num = Inf) %>% 
      rownames_to_column('feature') %>% 
      tbl_df()
  })

univar_rank <- model_features %>%
  split(.$component) %>% 
  map(~ split(., .$block)) %>% 
  modify_depth(2, pull, feature) %>% 
  map(~ {
    map2(., univar, ~ {
      .y[match(.x, .y$feature), ]
    })
  })

openxlsx::write.xlsx(unlist(univar_rank, recursive = F), 'univarrank_results_allblocks.xlsx', 
                     asTable = T, firstRow = T, colWidths = T)

univar_rank <- univar_rank %>% map(bind_rows, .id = 'block') %>% bind_rows(.id = 'component')

# table it
table(univar_rank$component, univar_rank$adj.P.Val <= 0.05)
table(univar_rank$block, univar_rank$adj.P.Val <= 0.05, univar_rank$component)

# The majority of features identified in the 1st component are univariate significant (FDR <= 0.05).
# In the 2nd component, corresponding to separation along DOL, a majority of features would not have been identified using univariate approaches.

# plot it
univar_rank %>% 
  ggplot(aes(-log10(adj.P.Val), fill = block)) +
  geom_histogram(position = 'dodge', binwidth = -log10(0.01)) +
  # geom_density() +
  geom_vline(xintercept = -log10(0.05), linetype = 'dashed') +
  scale_fill_manual(values = cols) +
  # scale_fill_fivethirtyeight() +
  # facet_grid(block ~ component, scales = 'free_y') +
  facet_wrap(~ component, ncol = 1) +
  theme(strip.background = element_blank())
```

# Compare enrichment in significant vs. not
```{r}
# first create cleaned up column of names
univar_rank$cleanname <- univar_rank$feature %>% 
  map(~ {
    x <- mapping$`Gene Symbols`[match(., mapping$`Data Names`)]
    x <- ifelse(is.na(x), ., x)
    x %>% gsub('^(.+)?\\n.+', '\\1', .) %>%
      # gsub('^.+_(.+)$', '\\1', .) %>%
      gsub('\\.', '', .) %>% 
      gsub("\\s", "", .)
  }) %>% flatten_chr()

univar_enrich <- univar_rank %>% 
  mutate(sig = adj.P.Val < 0.05) %>% 
  split(.$sig) %>% 
  map(pull, cleanname) %>% 
  map(sear) %>% 
  map(filter, fdr < 0.05, grepl('C2', collection)) %>% 
  map(arrange, fdr)

univar_enrich

univar_enrich %>% 
  map(mutate, rank = 1:n()) %>% 
  map(select, geneset, rank) %>% 
  reduce(full_join, by = 'geneset')

# write something about it...
# NABA matrisome
# NABA secreted factors
# NABA matrisome associated
```

# Cellular composition impact

Try to fit with `limma` with and without cells as covariates and compare p-values, rankings.


```{r}
library(eigenR2)

d <- model.matrix(~ subject.id, data = meta)
d1 <- model.matrix(~ subject.id + day, data = meta)
d2 <- model.matrix(~ subject.id + day + neutrophils + monocytes + CD4 + CD8 + NK + `B-Cells`, data = meta)

eigen <- map(X, ~ {
  e <- eigenR2(t(.), model = d2, null.model = d1)
  # data.frame(weights = head(e$weights, -1), eg.R2s = e$eg.R2s) %>%
  #   ggplot(aes(weights, eg.R2s)) +
  #   geom_point()
})


map2(eigen, names(eigen), ~ {
  p <- qplot(1:length(.x$weights), .x$weights, geom = 'point') +
    labs(x = 'PC', y = 'Prop. Var. Explained') +
    theme(aspect.ratio = 1)
  q <- qplot(1:length(.x$eg.R2s), .x$eg.R2s, geom = 'point') +
    labs(x = 'PC', y = expression(eigen~R^2)) +
    theme(aspect.ratio = 1)
  plot_grid(p, q, align = 'vh', nrow = 1) + ggtitle(sprintf('%s | R2 = %.2f', .y, .x$eigenR2))
})

```

```{r bib}
# create a bib file for the R packages used in this document
knitr::write_bib(c('base', 'rmarkdown'), file = 'skeleton.bib')
```
